\section{Diseño de interfaz}

\begin{frame}[t]{Archivos de cabecera}
\begin{itemize}
  \item Un archivo de cabecera contiene declaraciones que permiten el uso
        de entidades.
    \begin{itemize}
      \item Un archivo \cppid{.cpp} contiene definiciones de entidades.
    \end{itemize}
  \item \alert{Unidad de traducción}: Un archivo que se puede compilar, junto con
        todos los archivos de cabecera incluidos por él.
    \begin{itemize}
      \item Un archivo de cabecera puede participar en varias unidades de traducción.
      \item Un archivo de cabecera no debe contener definiciones de objetos (solamente declaraciones).
    \end{itemize}
  \item Cada unidad de traducción da lugar a un archivo objeto.
    \begin{itemize}
      \item No debe haber definiciones duplicadas de tipos de datos en dos unidades de traducción.
        \begin{itemize}
          \item Generaría problemas de enlace.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Inclusión múltiple}
\begin{itemize}
  \item \alert{Problema}: Inclusión múltiple de un archivo.
    \begin{itemize}
      \item Podría dar lugar a definiciones múltiples de tipos de datos.
    \end{itemize}
\end{itemize}
\begin{block}{fecha.h}
\begin{lstlisting}
struct fecha {
  int d, m, a;
};
\end{lstlisting}
\end{block}
\begin{block}{main.cpp}
\begin{lstlisting}
#include "fecha.h"
// Otros include
// ...
#include "fecha.h" // Redefinición de struct fecha
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Guardas de inclusión}
\begin{itemize}
  \item Usar un símbolo del preprocesador para evitar la inclusión múltiple.
    \begin{itemize}
      \item Todo el contenido del archivo de cabecera dentro de las guardas
    \end{itemize}
\end{itemize}
\begin{block}{fecha.h}
\begin{lstlisting}
#ifndef CALENDARIO_FECHA_H
#define CALENDARIO_FECHA_H

struct fecha {
  int d, m, a;
};

// Más declaraciones

#endif
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}{Organización de archivos de cabecera}
\begin{itemize}
  \item Alternativas.
    \begin{itemize}
      \item Un par archivo de cabecera/implementación por clase:
        \begin{itemize}
          \item Cabecera contiene la definición de la clase y funciones asociadas.
          \item Archivo \cppid{cpp} contiene definición de funciones.
          \item El usuario incluye las cabeceras que necesita.
        \end{itemize}
      \item Un único archivo de cabecera por biblioteca:
        \begin{itemize}
          \item Cabecera contiene todas las declaraciones de todos los tipos de la biblioteca.
          \item Uno o más archivo \cppid{cpp} contienen las definiciones.
          \item El usuario incluye una única cabecera.
        \end{itemize}
      \item Organización pragmática:
        \begin{itemize}
          \item Una cabecera por cada conjunto de tipos que es previsible usar juntos.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Iniciación de objetos}
\begin{itemize}
  \item Un tipo que tiene al menos un constructor necesita que se suministren
        argumentos al crear el objeto.
\begin{lstlisting}
fecha f{5, mes_id::marzo, 2000}; // OK
fecha f; // Error
\end{lstlisting}
    \begin{itemize}
      \item Objetivo: Evitar variables sin valor inicial.
    \end{itemize}
  \item Si se desea dar un valor por defecto a variables no iniciadas, se
        necesita definir un constructor por defecto.
\begin{lstlisting}
fecha::fecha() :
  dia_{1}, mes_{mes_id::enero}, anyo_{2000}
{
}

fecha f{}; // OK
fecha f; // OK
fecha f(); // Cuidado: define una función
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Función en-linea}
\begin{itemize}
  \item Una definición \alert{en-línea} es una sugerencia al compilador para que expanda
        el cuerpo de una función, en vez de generar el código de llamada.
    \begin{itemize}
      \item El compilador puede ignorar la sugerencia.
    \end{itemize}
\begin{lstlisting}
inline int cuadrado(int n) { 
  return n*n; 
}

int x = cuadrado(3); // Podría generar x = 9
int y = cuadrado(x); // Podria generar x = y*y
\end{lstlisting}
  \item Permite generar código pequeño, rápido y mantenible.
    \begin{itemize}
      \item Preferible al uso de macros.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Definiciones en-línea}
\begin{itemize}
  \item Reglas:
    \begin{itemize}
      \item La definición de una función \cppkey{inline} debe haberse visto antes de
            su primer uso.
\begin{lstlisting}
int cuadrado(int n);

x = cuadrado(2);

inline int cuadrado(int n) { return n*n; } // Error
\end{lstlisting}
      \item Si varias unidades de traducción contienen la misma función \cppkey{inline}
            su definición debe ser idéntica.
\begin{lstlisting}
// f1.cpp
inline int cuadrado(int n) { return n*n; }


// f2.cpp
inline int cuadrado(int n) { return 2*n*n/2; }
\end{lstlisting}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Organización y funciones en línea}
\begin{itemize}
  \item Colocar las definiciones de funciones \cppkey{inline} en archivos de cabecera.
    \begin{itemize}
      \item Definición vista antes de uso.
      \item Misma definición vista por todas las unidades de traducción.
    \end{itemize}
\end{itemize}
\begin{block}{fecha.h}
\begin{lstlisting}
#ifndef CALENDARIO_FECHA_H
#define CALENDARIO_FECHA_H

// ...

inline bool es_bisiesto(int a) {
  return ((a % 4 == 0 && a % 100 != 0) || (a % 400 == 0));
}

// ...

#endif
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Funciones miembro definidas dentro de clase}
\begin{itemize}
  \item Una función miembro definida dentro de una clase se considera una función miembro \cppkey{inline}.
\begin{lstlisting}
class fecha {
public:
  // ...
  fecha();
  // ...
private:
  int dia;
  mes_id mes;
  int anyo;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Equivalencia}
\begin{itemize}
  \item Es equivalente a definir la función en línea justo después de la definición de la clase.
\end{itemize}
\begin{lstlisting}
class fecha {
public:
  // ...
  fecha() : dia{1}, mes{mes_id::enero}, anyo{2000} {}
  // ...
private:
  int dia;
  mes_id mes;
  int anyo;
};

inline fecha::fecha() :
  dia{1},
  mes{mes_id::enero},
  anyo{2000}
{
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Objetos globales y enlace externo}
\begin{itemize}
  \item Una variable definida en una unidad de traducción tiene enlace externo.
    \begin{itemize}
      \item Puede accederse desde otras unidades de traducción con una declaración \cppkey{extern}.
    \end{itemize}
\end{itemize}
\begin{block}{a.cpp}
\begin{lstlisting}
int x = 1;
void f() {
  ++x;
}
\end{lstlisting}
\end{block}
\vspace{-0.25em}
\begin{block}{b.cpp}
\begin{lstlisting}
extern int x;
void g() {
  --x;
}
\end{lstlisting}
\end{block}
\begin{itemize}
  \item Los objetos globales son fuente de problemas en concurrencia.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Enlace interno}
\begin{itemize}
  \item Cualquier definición de alcance global o alcance de espacio de nombres
        calificada con \cppkey{const}, \cppkey{constexpr} o \cppkey{static}
        tiene enlace interno.
    \begin{itemize}
      \item No puede accederse desde otras unidades de traducción ni siquiera con \cppkey{extern}.
    \end{itemize}
\end{itemize}
\begin{block}{a.cpp}
\begin{lstlisting}
constexpr int max = 100;
const string nombre = "Daniel";
static vector<string> tabla { "uno", "dos" };
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Variables locales estáticas}
\begin{itemize}
  \item Dentro de una función, una variable estática se inicia solamente la primera vez.
\end{itemize}
\begin{lstlisting}
void imprime(color c) {
  const vector<string> nombres { "rojo", "verde", "azul" };
  static vector<int> usos { 0, 0, 0 };
  int id = static_cast<int>(c);
  if (id<0 || id>2) throw invalid_argument("Color no válido");
  ++usos[id];
  cout << "Usos de ";
  for (auto x : nombres) {
    cout << x << "  ";
  }
  cout << " --> ";
  for (auto x : usos) {
    cout << x << "  ";
  }
  cout << endl;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Modificabilidad}
\begin{itemize}
  \item Un objeto puede ser:
    \begin{itemize}
      \item \alert{Modificable}: Si se puede alterar su valor.
      \item \alert{Constante}: Si no se puede modificar su valor.
    \end{itemize}
  \item Una función puede aceptar:
    \begin{itemize}
      \item Parámetros por referencia no-constante:
        \begin{itemize}
          \item Solamente argumentos modificables.
        \end{itemize}
\begin{lstlisting}
void f(T & x);
\end{lstlisting}
      \item Parámetros por valor o por referencia constante:
        \begin{itemize}
          \item Argumentos modificables y no modificables.
        \end{itemize}
\begin{lstlisting}
void g(const T & x);
void h(T x);
\end{lstlisting}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Parámetros por referencia no-constante}
\begin{lstlisting}
void f(int & x) {
  ++x;
  cout << x << endl;
}

void g() {
  int z = 1;
  const int t = 2;
  f(z);
  f(t); // Error: No puede pasar objeto constante
  f(z+t); // Error: No puede pasar objeto temporal
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Parámetros por referencia constante}
\begin{lstlisting}
void f(const int & x) {
  ++x; // Error no se puede modificar x
  cout << x << endl;
}

void g() {
  int z = 1;
  const int t = 2;
  f(z);
  f(t); 
  f(z+t); 
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Parámetros y funciones miembro}
\begin{itemize}
  \item Cuando se invoca una función miembro se pasa implícitamente una \alert{referencia}
        al objeto para el que se invoca la función (el objeto \cppid{*this}).
\begin{lstlisting}
struct fecha {
  // ...
  int dia() { return d; }
  // ...
  int d; // Un dato miembro y una función miembro no se pueden llamar igual
};

int que_dia(fecha & f);

fecha cumple{4, id_mes::septiembre, 1969 };
int d = cumple.dia(); // d = que_dia(f)
const fecha inicio{1, id_mes::enero, 1969 };
int d2 = inicio.dia(); // Error: inicio es const
int d3 = que_dia(inicio); // Error: inicio es const
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Función miembro constante}
\begin{itemize}
  \item Una función miembro marcada como constante recibe de forma implícita una \alert{referencia constante}
        al objeto para el que se invoca la función (el objeto \cppid{*this}).
    \begin{itemize}
      \item Su implementación no pude modificar ningún dato miembro.
      \item Se puede invocar para objetos modificables y para objetos constantes.
    \end{itemize}
\begin{lstlisting}
class punto {
public:
  punto();
  double x() const { return x_; }
  double y() const { return y_; }
private:
  double x_, y_;
};

punto p1{2.0, 2.0};
auto x = p1.x();
const punto p2{0.0, 0.0};
auto y = p2.y();
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Miembros de acceso: ¿Siempre?}
\begin{lstlisting}
struct punto1 {
  double x, y;
};

class punto2 {
public:
  punto2() : x_{0}, y_{0} {}
  punto2(double x, double y) : x_{x}, y_{y} {}
  
  void x(double x) { x_ = x; }
  double x() const { return x_; }
  void y(double y) { y_ = y; }
  double y() const { return y_; }

private:
  double x_, y_;
};
\end{lstlisting}
\begin{itemize}
  \item Eficiencia / Mantenibilidad / Evolución.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Iniciación de miembros no estáticos}
\begin{itemize}
  \item Permite indicar el valor por defecto para un dato miembro en la declaración de una clase.
\begin{lstlisting}
class punto {
  private:
    double x{1.0};
    double y = 1.5;
};
\end{lstlisting}
  \item Equivalencia:
\begin{lstlisting}
class punto {
  public:
    punto() : x{1.0}, y{1.5} {}
  private:
    double x;
    double y;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Iniciación con múltiples constructores}
\begin{itemize}
  \item Problemas de mantenimiento cuando se tienen muchos constructores.
\end{itemize}
\begin{lstlisting}
class servicio {
  private:
    direccion dir;
    int puerto;
    string nombre;
  public:
    servicio() :
      dir(direccion_defecto), puerto(9025), nombre("sin nombre") {}
    servicio(direccion d) :
      dir(d), puerto(9025), nombre("sin nombre") {}
    servicio(direccion d, int p) :
      dir(d), puerto(p), nombre("sin nombre") {}
    servicio(string n) :
      dir(direccion_defecto), puerto(9025), nombre(n) {}
// ...
};
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Simplificación de iniciación}
\begin{itemize}
  \item Se puede refactorizar código para simplificar.
  \item La iniciación de un miembro en el constructor anula la iniciación en la definición
        de la variable miembro.
\end{itemize}
\begin{lstlisting}
class servicio {
  private:
    direccion dir{direccion_defecto};
    int puerto{9025};
    string nombre{"sin nombre"};
  public:
    servicio() {}
    servicio(direccion d) : dir{d} {}
    servicio(direccion d, int p) : dir{d}, puerto{p} {}
    servicio(string n) : nombre{n} {}
// ...
};
\end{lstlisting}
\end{frame}

\section{Ejemplo: Biblioteca de calendario}

\mode<presentation> {

\begin{frame}
\begin{block}{mes.h}
\lstinputlisting[lastline=21]{08-clases/fecha7/mes.h}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{mes.h}
\lstinputlisting[firstline=23]{08-clases/fecha7/mes.h}
\end{block}
\end{frame}

}

\mode<article> {
\begin{frame}
\begin{block}{mes.h}
\lstinputlisting{08-clases/fecha7/mes.h}
\end{block}
\end{frame}
}

\mode<presentation> {

\begin{frame}
\begin{block}{mes.cpp}
\lstinputlisting[lastline=13]{08-clases/fecha7/mes.cpp}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{mes.cpp}
\lstinputlisting[firstline=15, lastline=23]{08-clases/fecha7/mes.cpp}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{mes.cpp}
\lstinputlisting[firstline=25]{08-clases/fecha7/mes.cpp}
\end{block}
\end{frame}

}

\mode<article> {

\begin{frame}
\begin{block}{mes.cpp}
\lstinputlisting{08-clases/fecha7/mes.cpp}
\end{block}
\end{frame}

}

\mode<presentation> {

\begin{frame}
\begin{block}{fecha.h}
\lstinputlisting[lastline=19]{08-clases/fecha7/fecha.h}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{fecha.h}
\lstinputlisting[firstline=21]{08-clases/fecha7/fecha.h}
\end{block}
\end{frame}

}

\mode<article> {
\begin{frame}
\begin{block}{fecha.h}
\lstinputlisting{08-clases/fecha7/fecha.h}
\end{block}
\end{frame}
}

\mode<presentation>{

\begin{frame}
\begin{block}{fecha.cpp}
\lstinputlisting[lastline=20]{08-clases/fecha7/fecha.cpp}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{fecha.cpp}
\lstinputlisting[firstline=22,lastline=36]{08-clases/fecha7/fecha.cpp}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{fecha.cpp}
\lstinputlisting[firstline=38]{08-clases/fecha7/fecha.cpp}
\end{block}
\end{frame}

}

\mode<article>{
\begin{frame}
\begin{block}{fecha.cpp}
\lstinputlisting{08-clases/fecha7/fecha.cpp}
\end{block}
\end{frame}
}
